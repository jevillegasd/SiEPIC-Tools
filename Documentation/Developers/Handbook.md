 # SiEPIC-Tools Developers Handbook
 
This document summarized the modules and functionalities of **SiEPIC-Tools**, an Open-source Python package that enables Photonic Integrated Circuits (PICs) Process Development Kits (PDKs) through the KLayout ([www.klayout.de](http://www.klayout.de)) layout viewer. This package was 


The guide in this document is meant to be used as a programming reference for current and future developers of the SiEPIC-Tools project and as the package’s conventions and standards manual. Please refer to the repository’s webpage ([https://github.com/lukasc-ubc/SiEPIC-Tools](https://github.com/lukasc-ubc/SiEPIC-Tools)) for a guide on how to contribute and publish updates to the package.

 In addition to being a guide, this document will highlight sections of legacy code in an effort to identify and clean-up the package of old, unused scripts and routines.

*Developers*: Please keep this document up-to-date as SiEPIC-Tools updates.

**To-do**: please add the following information to this document:
* Features available in the SiEPIC-Tools package
* Implement unit-testing for SiEPIC-Tools modules, i.e. single script that can be ran to confirm functionality of all SiEPIC-Tools features.

## Table of Contents
- [SiEPIC-Tools Developers Handbook](#siepic-tools-developers-handbook)
  * [Python modules](#python-modules)
    + [1. `__init__`](#1----init---)
    + [2. `_globals`](#2---globals-)
    + [3. `calibre_temp`](#3--calibre-temp-)
      - [a. Method: `calibreDRC( params, cell)`](#a-method---calibredrc--params--cell--)
    + [4. `core`](#4--core-)
      - [a. Class `Net`](#a-class--net-)
      - [b. Class `Pin`](#b-class--pin-)
      - [c. Method `display_pins( pins )`](#c-method--display-pins--pins---)
      - [d. Class `Component`](#d-class--component-)
      - [e. Class `WaveguideGUI`](#e-class--waveguidegui-)
      - [f. Class `MonteCarloGUI`](#f-class--montecarlogui-)
    + [5. `example_gr`](#5--example-gr-)
    + [6 `examples`](#6--examples-)
    + [7. `extend`](#7--extend-)
    + [8. `github`](#8--github-)
    + [9. `install`](#9--install-)
    + [10. `netlist`](#10--netlist-)
    + [11. `lumerical`](#11--lumerical-)
      - [a. `__init__`](#a----init---)
      - [b. `fdtd`](#b--fdtd-)
      - [c. `interconnect`](#c--interconnect-)
      - [d. `mode`](#d--mode-)
      - [e. `load_lumapi`](#e--load-lumapi-)
      - [f. `ApodizedContraDC`](#f--apodizedcontradc-)
    + [12. `scripts`](#12--scripts-)
    + [13. `setup`](#13--setup-)
    + [14. `utils`](#14--utils-)
      - [a. `__init__`](#a----init----1)
      - [b. `geometry`](#b--geometry-)
      - [c. `layout`](#c--layout-)

## Python modules
### 1. `__init__`
The `___init__.py` files are required to make Python treat the directories as containing packages; this is done to prevent directories with a common name, such as string, from unintentionally hiding valid modules that occur later on the module search path. In the simplest case, `___init__.py` can just be an empty file, but it can also execute initialization code for the package or set the`__all__` variable, described later. In this case of SiEPIC-Tools, `__init__.py` is used to execute the initialization code for the package.


------
### 2. `_globals`
The `_globals.py` defines global variables used across the SiEPIC-Tools package. Such variables include package directories, package settings, and pin definitions.

------
### 3. `calibre_temp`
* #### a. Method: `calibreDRC( params, cell)`
Sends the current view layout to a remote server with Mentor Calibre to apply a DRC check. The settings for the server are defined in the `CALIBRE.xml` file that is defined in the PDK's technology file.

------
### 4. `core`
The `core.py` contains definitions to the layout classes that enable Netlist connectivity in SiEPIC-Tools and defines some of its GUI interfaces.

* #### a. Class `Net`
	The *Net* class defines connectivity between *Pins*. It is used for Netlist generation and verification data generated by class extensions `cell.identify_nets()`. An optical *Net* can only have two *Pins*, electrical *Nets* can have multiple.

	* ##### Method: `___init___()`
		The `___init___` defines the *Net* variables including:

		* *idx:* defines the unique *Net* number
	
		* *type:* defines the *Pin* type from the available PIN_TYPES in `__globals.py`
	
		* *pins:* which is the *Pin* array that points to *Pins*.

	* ##### Method: `display()`
		The display function queries the *Net* and displays it’s information, including the index, the pins its connected to.
 
* #### b. Class `Pin`
	The *Pin* class is a class that describes *Pins* on *Components* and waveguides. A *Pin* can be associated with a *Component* and/or a *Net*. A *Pin* consists of:

	* *Optical Pin:* a path with two points, with its vector direction indicating the connectivity direction of the *Component*.
	
	* *Electrical Pin:* a box.
	
	* *Text label:* indicating a *Pin* name.
	
	* *Type:* indicating a *Pin* type.

	The *Pin* class is used for:
	* Component snapping to nearest *Pin* (in snap_component)
	
	* Waveguide snapping to nearest *Pin* (in waveguide_from_path and path.snap). This functionality does not need info about the *Component*, *Net*, ..
	
	* Netlist extraction where the *Pin* connectivity is needed to know which *Component* and *Net* the *Pin* belongs to.

	The methods available in this class are: 
	* ##### Method: `___init___()`
		The `__init__` defines the Pin variables including:
		* *type:* defines the *Pin* type from the available PIN_TYPES in `__globals.py`
	
		* *net:* the *Net* the *Pin* is connected to or if *Pin* is disconnected.

		* *pin_name:* label read from the cell layout (layout PinRec text)

		* *component:* the *Component* index the *Pin* belongs to
	
		* *path:* the *Pin's* path (in case of optical *Pin* type)
	
		* *polygon:* the *Pin's* polygon (in case of optical IO *Pin* type, i.e. fiber)

		* *center:* center coordinate of the *Pin* (a point)

		* *rotation:* angle/direction of the optical *Pin* (in case of path, 0 otherwise)

	* ##### Method: `transform( trans )`
		The `transform` method applies a transformation to the *Pin* location by trans.

	* ##### Method: `display()`
		The `display` method queries the *Pin* and displays it’s information, including the index, *Net* it belongs to, *Component* it belongs to, type, *Net* index, center coordinate, path vectors.
		
* #### c. Method `display_pins( pins )`
	The `display_pins` method queries all the available *Pins* and uses the internal *Pin* display method to print their information on console.

* #### d. Class `Component`
	The *Component* describes devices (such as PCells or fixed geometry) in the layout. A *Component* consist:

	* A physical layout representation
	* Additional *Component* descriptors in text format
	* *Pin(s)* to identify the *Component* ports.

	This *Component* class is used for:
	* Netlist extraction - in which the *Component* connectivity is needed to know which *Net(s)* connect the *Component(s)* together. 

	The methods available in this class are:
 
 	* ##### Method: `__init__()`
		The `__init__` method defines the class variable which include:
	
		* *idx:* The unique component index identified (0, 1, ...)
		
		*  *component:* 
		*  *instance:*
		*  *trans:*
		*  *library:*
		*  *pins:*
		*  *npins:*
		*  *params:*
		*  *polygon:*
		*  *DevRec_polygon:*
		*  *center:*
		*  *cell:*
		*  *basic_name:*
		*  *TECHNOLOGY:*
		*  *Dcenter:*
 
  	* ##### Method: `display()`
		The `display` method 

 	* ##### Method: `find_pins()`
		The `find_pins` method

 	* ##### Method: `has_model()`
		The `has_model` method

 	* ##### Method: `get_polygons()`
		The `get_polygons` method
		
	* ##### Method: `set_SPICE_params(component, arg, verbose)`
		Setter method for SPICE parameters. Inputs are either a string with SPICE parameters or a dictionnary with all the SPICE parameters to be included in the component. It will also override the parameters written in the cell component.
		###### **Inputs**
		*	*component*:  	A SIEPIC.core.component instance.
		*	*arg*:		A string with the SPICE parameters or a dictionnary where each memeber is a SPICE parameter.
		*	*verbose*:	Boolean, true to print command outputs.
 
 	* ##### Method: `get_SPICE_params()`
		Getter method for SPICE parameters. Returns a dictionnary with the SPICE marameter of the component.
* #### e. Class `WaveguideGUI`
* #### f. Class `MonteCarloGUI`

------
### 5. `example_gr`
Legacy

------
### 6 `examples`
Legacy

------
### 7. `extend`
The `extend` module

**The methods below  are used as extensions to pya.Path and pya.DPath:**

* #### a. Method `to_dtype( dbu )`
	The `to_dtype` method 

* #### b. Method `to_itype( dbu )`
	The `to_itype` method 

* #### c. Method `get_points()`
	The `get_points` method 

* #### d. Method `get_dpoints()`
	The `get_dpoints` method 
	
* #### e. Method `is_manhattan_endsegments()`
	The `is_manhattan_endsegments` method 

* #### f. Method `is_manhattan()`
	The `is_manhattan` method 

* #### g. Method `radius_check( radius )`
	The `radius_check` method 

* #### h. Method `remove_colinear_points()`
	The `remove_colinear_points` method 

* #### i. Method `unique_points()`
	The `unique_points` method 

* #### j. Method `translate_from_center( offset )`
	The `translate_from_center` method 

* #### k. Method `snap( pins )`
	The `snap` method 

**The methods below  are used as extensions to pya.Polygon and pya.DPolygon:**

* #### l. Method `get_points()`
	The `get_points` method 
	
* #### m. Method `get_dpoints()`
	The `get_dpoints` method 

* #### n. Method `to_dtype( dbu )`
	The `to_dtype` method 

**The methods below  are used as extensions to pya PCell Declaration Helper class (pya.PCellDeclarationHelper):**

* #### o. Method `print_parameter_list( dbu )`
	The `print_parameter_list` method 
	
**The methods below  are used as extensions to pya PCell class (pya.Cell):**

* #### p. Method `print_parameter_list( dbu )`
	The `print_parameter_list` method 
	
* #### q. Method `find_pins( verbose, polygon_devrec )`
	The `find_pins` method 
	
* #### r. Method `find_pin( name )`
	The `find_pin` method 
	
* #### s. Method `find_pins_component( verbose, cell_selected )`
	The `find_pins_component` method 

* #### t. Method `find_components( verbose, cell_selected )`
	The `cell_selected` method 
	
* #### u. Method `identify_nets( verbose)`
	The `identify_nets` method 
	
* #### v. Class `detector_info`
	The `detector_info` class 
	
* #### w. Method `get_LumericalINTERCONNECT_analyzers( components, verbose )`
	The `get_LumericalINTERCONNECT_analyzers` method 

* #### x. Method `get_LumericalINTERCONNECT_analyzers_from_opt_in( components, verbose, opt_in_selection_text )`
	The `get_LumericalINTERCONNECT_analyzers_from_opt_in` method 
	
* #### y. Method `spice_netlist_export( verbose, opt_in_selection_text )`
	The `spice_netlist_export` method 

* #### z. Method `check_component_models()`
	The `check_component_models` method 

**The methods below  are used as extensions to pya Instance class (pya.Instance):**
	
* #### aa. Method `find_pins( verbose )`
	The `find_pins` method 	

**The methods below  are used as extensions to pya Point and DPoint classes (pya.Point and pya.DPoint):**

* #### ab. Method `to_dtype( dbu )`
	The `to_dtype` method 	

* #### ac. Method `to_itype( dbu )`
	The `to_itype` method 	

* #### ad. Method `to_p()`
	The `to_p` method is only applicable for KLayout v0.24 and older. 	

* #### ae. Method `angle_vector( u )`
	The `angle_vector` method 	

**The methods below  are used as extensions to pya Point and Vector classes (pya.Point and pya.Vector):**

* #### af. Method `pyaPoint__rmul__( factor )`
	The `pyaPoint__rmul__` method 	

* #### ag. Method `pyaPoint__mul__( factor )`
	The `pyaPoint__mul__` method 	

* #### ah. Method `pyaPoint__truediv__( dividend )`
	The `pyaPoint__truediv__` method 	

* #### ai. Method `pyaPoint__norm__()`
	The `pyaPoint__norm__` method 	
	
* #### aj. Class `PointLike()`
	The `PointLike` class  	
	
**The methods below  are used for dbu  (int)to float conversions:**

* #### af. Method `to_dbu( f, dbu )`
	The `to_dbu` method 	

* #### af. Method `to_itype( f, dbu )`
	The `to_itype` method 	
	
* #### af. Method `from_dbu( i, dbu )`
	The `from_dbu` method 	
	
* #### af. Method `to_dtype( i, dbu )`
	The `to_dtype` method 	
	
------
### 8. `github`

* #### a. Method `github_get_filenames( user, repo, filesearch, extension, auth, verbose)`
	The `github_get_filenames` method
	
* #### b. Method `github_get_files( user, repo, filename_search, save_folder, auth, include_path, verbose)`
	The `github_get_files` method
	
* #### c. Method `github_get_file( user, repo, filename_search, save_folder, auth, include_path, verbose)`
	The `github_get_file` method
------
### 9. `install`

* #### a. Method `install_ssh()`
	The `install_ssh` method

* #### a. Method `install_dependencies()`
	The `install_dependencies` method
	
* #### a. Method `install_lumapi()`
	The `install_lumapi` method
	
* #### a. Method `get_pip_main()`
	The `get_pip_main` method
	
* #### a. Method `install_numpy()`
	The `install_numpy` method
	
* #### a. Method `install_scipy()`
	The `install_scipy` method
	
------
### 10. `lumerical`
* #### a. `__init__`

* #### b. `fdtd`

	* ##### Method: `run_FDTD( verbose )`
		The `run_FDTD` method

	* ##### Method: `generate_component_sparam( do_simulation, addto_CML, verbose, FDTD_settings )`
		The `generate_component_sparam` method

	* ##### Method: `generate_GC_sparam( do_simulation, addto_CML, verbose, FDTD_settings, GC_settings )`
		The `generate_GC_sparam` method

	* ##### Method: `generate_CDC_bandstructure( W_1, W_2, dW_11, dW_2, period, gap, sinusoidal, verbose )`
		The `generate_CDC_bandstructure` method
		
		
* #### c. `interconnect`

	* ##### Method: `run_INTC( verbose )`
		The `run_INTC` method
		
	* ##### Method: `Setup_Lumerical_KLayoutPython_integration( verbose )`
		The `Setup_Lumerical_KLayoutPython_integration` method

	* ##### Method: `run_INTC( verbose )`
		The `run_INTC` method

	* ##### Method: `INTC_commandline( filename2 )`
		The `INTC_commandline` method
		
	* ##### Method: `component_simulation( verbose, simulate )`
		The `component_simulation` method
		
* #### d. `mode`
* #### e. `load_lumapi`
* #### f. `ApodizedContraDC`

------
### 11. `netlist`

------
### 12. `scripts`

------
### 13. `setup`

------
### 14. `utils`
* #### a. `__init__`
* #### b. `geometry`
* #### c. `layout`
* #### d. `sampling`
* #### e. `crossing`
	Util to insert a crossing cell between intersecting paths as waveguides are instantiated. Works only for path intersecting paths but not with existing waveguide cells nor self intersecting paths.   
	* ##### Method: `insert_crossing(selected_paths, params, verbose= False)`
		Method to insert crossings between any number of paths
		###### **Inputs**
		* *selected_path*: Array of instances (ObjInstPath) pointing to the selected paths, can be generated from `utils.select_paths(tech,cell)`
		* *params*: Dictionnary with fields:
			* `crossing_cell`:	string, name of cell for the waveguide crossing. 
			* `crossing_library`:	string, name of library (technology) of the wavguide crossing.
			* `crossing_offset`:	1x2 double array, [x, y] offests of the cell origin with respect to its geometric center. 
		* *verbose*: Boolean, true to print outputs in the console.
			 
		###### **Outputs**
		* *selected_path*: Array of instances (ObjInstPath) pointing to the updated list of paths after breaking and cutting at the crossing positions.

	* ##### Method: `cross_2paths()` 
		Method to insert a crossing between two paths.
		###### **Inputs**
		* *oip_path1*:  Instance (ObjInstPath) of the first path object.
		* *oip_path2*:  Instance (ObjInstPath) of the second path object.
		* *xcell*:  Cell ptr to the crossing cell. 
		* *origin*:  pya.Trans object with the crossing cell origin transformation.
		* *verbose*:  boolean, true to print outputs in the console.
		
		###### **Outputs**
		* *new_path1*:  Array size 2 with instances (ObjInstPath) of the two paths resulting from breaking oip_path1.
		* *new_path2*:  Array size 2 with instances (ObjInstPath) of the two paths resulting from breaking oip_path2.
		* *flag*:	Boolena, True if a crossing cell is correctly placed.
